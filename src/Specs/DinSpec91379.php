<?php

declare(strict_types=1);

namespace LupusCoding\DinValidator\Specs;

use LupusCoding\DinValidator\Helper\EncodingConverter;

/**
 * Class DinSpec91379
 * @package LupusCoding\DinValidator\Specs
 * @author Ralph Dittrich <dittrich.ralph@lupuscoding.de>
 */
class DinSpec91379
{
    /** Test a character if it is available in list Latin */
    public function isLatinCharacter(string $character): bool
    {
        $unicodePoint = EncodingConverter::utf8ToUnicode($character);
        return ($unicodePoint && $this->isLatinUnicodePoint($unicodePoint));
    }

    /** Test a unicode point if it is available in list Latin */
    protected function isLatinUnicodePoint(int $unicodePoint): bool
    {
        return in_array($unicodePoint, [
            0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, 0x0048, 0x0049,
            0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
            0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, 0x0059,
            0x005a,
            0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, 0x0068, 0x0069,
            0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
            0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, 0x0079,
            0x007a,
            0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7, 0x00c8, 0x00c9,
            0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,
            0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d8, 0x00d9,
            0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,
            0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7, 0x00e8, 0x00e9,
            0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,
            0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f8, 0x00f9,
            0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,
            0x0100, 0x0101, 0x0102, 0x0103, 0x0104, 0x0105, 0x0106, 0x0107, 0x0108, 0x0109,
            0x010a, 0x010b, 0x010c, 0x010d, 0x010e, 0x010f,
            0x0110, 0x0111, 0x0112, 0x0113, 0x0114, 0x0115, 0x0116, 0x0117, 0x0118, 0x0119,
            0x011a, 0x011b, 0x011c, 0x011d, 0x011e, 0x011f,
            0x0120, 0x0121, 0x0122, 0x0123, 0x0124, 0x0125, 0x0126, 0x0127, 0x0128, 0x0129,
            0x012a, 0x012b, 0x012c, 0x012d, 0x012e, 0x012f,
            0x0130, 0x0131, 0x0132, 0x0133, 0x0134, 0x0135, 0x0136, 0x0137, 0x0138, 0x0139,
            0x013a, 0x013b, 0x013c, 0x013d, 0x013e, 0x013f,
            0x0140, 0x0141, 0x0142, 0x0143, 0x0144, 0x0145, 0x0146, 0x0147, 0x0148, 0x0149,
            0x014a, 0x014b, 0x014c, 0x014d, 0x014e, 0x014f,
            0x0150, 0x0151, 0x0152, 0x0153, 0x0154, 0x0155, 0x0156, 0x0157, 0x0158, 0x0159,
            0x015a, 0x015b, 0x015c, 0x015d, 0x015e, 0x015f,
            0x0160, 0x0161, 0x0162, 0x0163, 0x0164, 0x0165, 0x0166, 0x0167, 0x0168, 0x0169,
            0x016a, 0x016b, 0x016c, 0x016d, 0x016e, 0x016f,
            0x0170, 0x0171, 0x0172, 0x0173, 0x0174, 0x0175, 0x0176, 0x0177, 0x0178, 0x0179,
            0x017a, 0x017b, 0x017c, 0x017d, 0x017e,
            0x0187, 0x0188,
            0x018f,
            0x0197,
            0x01a0, 0x01a1,
            0x01af,
            0x01b0,0x01b7,
            0x01cd, 0x01ce, 0x01cf,
            0x01d0, 0x01d1, 0x01d2, 0x01d3, 0x01d4, 0x01d5, 0x01d6, 0x01d7, 0x01d8, 0x01d9,
            0x01da, 0x01db, 0x01dc, 0x01de, 0x01df,
            0x01e2, 0x01e3, 0x01e4, 0x01e5, 0x01e6, 0x01e7, 0x01e8, 0x01e9,
            0x01ea, 0x01eb, 0x01ec, 0x01ed, 0x01ee, 0x01ef,
            0x01f0, 0x01f4, 0x01f5, 0x01f8, 0x01f9,
            0x01fa, 0x01fb, 0x01fc, 0x01fd, 0x01fe, 0x01ff,
            0x0212, 0x0213, 0x0218, 0x0219,
            0x021a, 0x021b, 0x021e, 0x021f,
            0x0227, 0x0228, 0x0229,
            0x022a, 0x022b, 0x022c, 0x022d, 0x022e, 0x022f,
            0x0230, 0x0231, 0x0232, 0x0233,
            0x0259,
            0x0268,
            0x0292,
            0x1e02, 0x1e03, 0x1e06, 0x1e07,
            0x1e0a, 0x1e0b, 0x1e0c, 0x1e0d, 0x1e0e, 0x1e0f,
            0x1e10, 0x1e11,
            0x1e1c, 0x1e1d, 0x1e1e, 0x1e1f,
            0x1e20, 0x1e21, 0x1e22, 0x1e23, 0x1e24, 0x1e25, 0x1e26, 0x1e27, 0x1e28, 0x1e29,
            0x1e2a, 0x1e2b, 0x1e2f,
            0x1e30, 0x1e31, 0x1e32, 0x1e33, 0x1e34, 0x1e35, 0x1e36, 0x1e37,
            0x1e3a, 0x1e3b,
            0x1e40, 0x1e41, 0x1e42, 0x1e43, 0x1e44, 0x1e45, 0x1e46, 0x1e47, 0x1e48, 0x1e49,
            0x1e52, 0x1e53, 0x1e54, 0x1e55, 0x1e56, 0x1e57, 0x1e58, 0x1e59,
            0x1e5a, 0x1e5b, 0x1e5e, 0x1e5f,
            0x1e60, 0x1e61, 0x1e62, 0x1e63,
            0x1e6a, 0x1e6b, 0x1e6c, 0x1e6d, 0x1e6e, 0x1e6f,
            0x1e80, 0x1e81, 0x1e82, 0x1e83, 0x1e84, 0x1e85, 0x1e86, 0x1e87,
            0x1e8c, 0x1e8d, 0x1e8e, 0x1e8f,
            0x1e90, 0x1e91, 0x1e92, 0x1e93, 0x1e94, 0x1e95, 0x1e96, 0x1e97,
            0x1e9e,
            0x1ea1, 0x1ea2, 0x1ea3, 0x1ea4, 0x1ea5, 0x1ea6, 0x1ea7, 0x1ea8, 0x1ea9,
            0x1eaa, 0x1eab, 0x1eac, 0x1ead, 0x1eae, 0x1eaf,
            0x1eb0, 0x1eb1, 0x1eb2, 0x1eb3, 0x1eb4, 0x1eb5, 0x1eb6, 0x1eb7, 0x1eb8, 0x1eb9,
            0x1eba, 0x1ebb, 0x1ebc, 0x1ebd, 0x1ebe, 0x1ebf,
            0x1ec0, 0x1ec1, 0x1ec2, 0x1ec3, 0x1ec4, 0x1ec5, 0x1ec6, 0x1ec7, 0x1ec8, 0x1ec9,
            0x1eca, 0x1ecb, 0x1ecc, 0x1ecd, 0x1ece, 0x1ecf,
            0x1ed0, 0x1ed1, 0x1ed2, 0x1ed3, 0x1ed4, 0x1ed5, 0x1ed6, 0x1ed7, 0x1ed8, 0x1ed9,
            0x1eda, 0x1edb, 0x1edc, 0x1edd, 0x1ede, 0x1edf,
            0x1ee0, 0x1ee1, 0x1ee2, 0x1ee3, 0x1ee4, 0x1ee5, 0x1ee6, 0x1ee7, 0x1ee8, 0x1ee9,
            0x1eea, 0x1eeb, 0x1eec, 0x1eed, 0x1eee, 0x1eef,
            0x1ef0, 0x1ef1, 0x1ef2, 0x1ef3, 0x1ef4, 0x1ef5, 0x1ef6, 0x1ef7, 0x1ef8, 0x1ef9,
        ]);
    }

    /** Test a character if it is available in list Diacritical Combined
     * Caution: Some diacritical characters are not convertable on their own. They require additional characters.
     */
    public function isDiacriticalCombinationCharacter(string $character): bool
    {
        $unicodePoint = EncodingConverter::utf8ToUnicode($character);
        return ($unicodePoint && $this->isDiacriticalCombinationUnicodePoint($unicodePoint));
    }

    /** Test a unicode point if it is available in list Diacritical Combined
     * Caution: Some diacritical characters are not convertable on their own. They require additional characters.
     */
    protected function isDiacriticalCombinationUnicodePoint(int $unicodePoint): bool
    {
        // HINT: 1 unicode diacritical combination character is always converted to 2 unicode points
        return in_array($unicodePoint,
            [
                0x0300, 0x0301, 0x0302, 0x0304, 0x0306, 0x0307, 0x0308,
                0x030b, 0x030c,
                0x0310, 0x0315,
                0x031b,
                0x0323, 0x0325, 0x0326, 0x0327, 0x0328,
                0x0331,
                0x035f
            ]
        );
    }

    /** Test a string if it is a valid combination of unicode points */
    public function isDiacriticalCombinedString(string $string): bool
    {
        $latinChar = EncodingConverter::utf8ToUnicode(substr($string, 0, 1));
        $diacriticals = [];
        foreach (str_split(substr($string, 1)) as $diacritialChar) {
            $diacriticals[] = EncodingConverter::utf8ToUnicode($diacritialChar);
        }
        return $this->isDiacriticalCombinedPoints($latinChar, $diacriticals);
    }

    /** Test a set of unicode points if they are a valid combination
     * @param int[] $unicodeDiacriticals A list of unicode points
     */
    protected function isDiacriticalCombinedPoints(int $unicodeLatinChar, array $unicodeDiacriticals): bool
    {
        $combination = $unicodeLatinChar . implode('', $unicodeDiacriticals);
        return in_array($combination, [
            0x0041 . 0x030b, 0x0043 . 0x0300, 0x0043 . 0x0304, 0x0043 . 0x0306, 0x0043 . 0x0308, 0x0043 . 0x0315,
            0x0043 . 0x0323, 0x0043 . 0x0326, 0x0043 . 0x0328 . 0x0306,
            0x0044 . 0x0302,
            0x0046 . 0x0300, 0x0046 . 0x0304,
            0x0047 . 0x0300,
            0x0048 . 0x0304, 0x0048 . 0x0326, 0x0048 . 0x0331,
            0x004a . 0x0301, 0x004a . 0x030c,
            0x004b . 0x0300, 0x004b . 0x0302, 0x004b . 0x0304, 0x004b . 0x0307, 0x004b . 0x0315, 0x004b . 0x031b,
            0x004b . 0x0326, 0x004b . 0x035f . 0x0048, 0x004b . 0x035f . 0x0068,
            0x004c . 0x0302, 0x004c . 0x0325, 0x004c . 0x0325 . 0x0304, 0x004c . 0x0326,
            0x004d . 0x0300, 0x004d . 0x0302, 0x004d . 0x0306, 0x004d . 0x0310,
            0x004e . 0x0302, 0x004e . 0x0304, 0x004e . 0x0306, 0x004e . 0x0326,
            0x0050 . 0x0300, 0x0050 . 0x0304, 0x0050 . 0x0315, 0x0050 . 0x0323,
            0x0052 . 0x0306, 0x0052 . 0x0325, 0x0052 . 0x0325 . 0x0304,
            0x0053 . 0x0300, 0x0053 . 0x0304, 0x0053 . 0x031b . 0x0304, 0x0053 . 0x0331,
            0x0054 . 0x0300, 0x0054 . 0x0304, 0x0054 . 0x0308, 0x0054 . 0x0315, 0x0054 . 0x031b,
            0x0055 . 0x0307,
            0x005a . 0x0300, 0x005a . 0x0304, 0x005a . 0x0306, 0x005a . 0x0308, 0x005a . 0x0327,
            0x0061 . 0x030b,
            0x0063 . 0x0300, 0x0063 . 0x0304, 0x0063 . 0x0306, 0x0063 . 0x0308, 0x0063 . 0x0315, 0x0063 . 0x0323,
            0x0063 . 0x0326, 0x0063 . 0x0328 . 0x0306,
            0x0064 . 0x0302,
            0x0066 . 0x0300, 0x0066 . 0x0304,
            0x0067 . 0x0300,
            0x0068 . 0x0304, 0x0068 . 0x0326,
            0x006a . 0x0301,
            0x006b . 0x0300, 0x006b . 0x0302, 0x006b . 0x0304, 0x006b . 0x0307, 0x006b . 0x0315, 0x006b . 0x031b,
            0x006b . 0x0326, 0x006b . 0x035f . 0x0068,
            0x006c . 0x0302, 0x006c . 0x0325, 0x006c . 0x0325 . 0x0304, 0x006c . 0x0326,
            0x006d . 0x0300, 0x006d . 0x0302, 0x006d . 0x0306, 0x006d . 0x0310,
            0x006e . 0x0302, 0x006e . 0x0304, 0x006e . 0x0306, 0x006e . 0x0326,
            0x0070 . 0x0300, 0x0070 . 0x0304, 0x0070 . 0x0315, 0x0070 . 0x0323,
            0x0072 . 0x0306, 0x0072 . 0x0325, 0x0072 . 0x0325 . 0x0304,
            0x0073 . 0x0300, 0x0073 . 0x0304, 0x0073 . 0x031b . 0x0304, 0x0073 . 0x0331,
            0x0074 . 0x0300, 0x0074 . 0x0304, 0x0074 . 0x0315, 0x0074 . 0x031b,
            0x0075 . 0x0307,
            0x007a . 0x0300, 0x007a . 0x0304, 0x007a . 0x0306, 0x007a . 0x0308, 0x007a . 0x0327,
            0x00c7 . 0x0306,
            0x00db . 0x0304,
            0x00e7 . 0x0306,
            0x00fb . 0x0304,
            0x00ff . 0x0301,
            0x010c . 0x0315, 0x010c . 0x0323,
            0x010d . 0x0315, 0x010d . 0x0323,
            0x012a . 0x0301,
            0x012b . 0x0301,
            0x017d . 0x0326, 0x017d . 0x0327,
            0x017e . 0x0326, 0x017e . 0x0327,
            0x1e32 . 0x0304,
            0x1e33 . 0x0304,
            0x1e62 . 0x0304,
            0x1e63 . 0x0304,
            0x1e6c . 0x0304,
            0x1e6d . 0x0304,
            0x1ea0 . 0x0308,
            0x1ea1 . 0x0308,
            0x1ecc . 0x0308,
            0x1ecd . 0x0308,
            0x1ee4 . 0x0304, 0x1ee4 . 0x0308,
            0x1ee5 . 0x0304, 0x1ee5 . 0x0308
        ]);
    }

    /** Test a character if it is available in list NonLetter N1 */
    public function isNonLetterN1Character(string $character): bool
    {
        $unicodePoint = EncodingConverter::utf8ToUnicode($character);
        return ($unicodePoint && $this->isNonLetterN1UnicodePoint($unicodePoint));
    }

    /** Test a unicode point if it is available in list NonLetter N1 */
    public function isNonLetterN1UnicodePoint(int $unicodePoint): bool
    {
        return in_array($unicodePoint, [
            0x0020, 0x0027,
            0x002c, 0x002d, 0x002e,
            0x0060,
            0x007e,
            0x00a8,
            0x00b4, 0x00b7,
            0x02b9,
            0x02ba, 0x02be, 0x02bf,
            0x02c8,
            0x02cc,
            0x2019,
            0x2021
        ]);
    }

    /** Test a character if it is available in list NonLetter N2 */
    public function isNonLetterN2Character(string $character): bool
    {
        $unicodePoint = EncodingConverter::utf8ToUnicode($character);
        return ($unicodePoint && $this->isNonLetterN2UnicodePoint($unicodePoint));
    }

    /** Test a unicode point if it is available in list NonLetter N2 */
    public function isNonLetterN2UnicodePoint(int $unicodePoint): bool
    {
        return in_array($unicodePoint, [
            0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0028, 0x0029,
            0x002a, 0x002b, 0x002f,
            0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, 0x0038, 0x0039,
            0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
            0x0040,
            0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
            0x007b, 0x007c, 0x007d,
            0x00a1, 0x00a2, 0x00a3, 0x00a5, 0x00a7, 0x00a9,
            0x00aa, 0x00ab, 0x00ac, 0x00ae, 0x00af,
            0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b5, 0x00b6, 0x00b9,
            0x00ba, 0x00bb, 0x00bf,
            0x00d7,
            0x00f7,
            0x20ac
        ]);
    }

    /** Test a character if it is available in list NonLetter N3 */
    public function isNonLetterN3Character(string $character): bool
    {
        $unicodePoint = EncodingConverter::utf8ToUnicode($character);
        return ($unicodePoint && $this->isNonLetterN3UnicodePoint($unicodePoint));
    }

    /** Test a unicode point if it is available in list NonLetter N3 */
    protected function isNonLetterN3UnicodePoint(int $unicodePoint): bool
    {
        return in_array($unicodePoint, [
            0x00a4, 0x00a6,
            0x00b8,
            0x00bc, 0x00bd, 0x00be
        ]);
    }

    /** Test a character if it is available in list NonLetter N4 */
    public function isNonLetterN4Character(string $character): bool
    {
        $unicodePoint = EncodingConverter::utf8ToUnicode($character);
        return ($unicodePoint && $this->isNonLetterN4UnicodePoint($unicodePoint));
    }

    /** Test a unicode point if it is available in list NonLetter N4 */
    protected function isNonLetterN4UnicodePoint(int $unicodePoint): bool
    {
        return in_array($unicodePoint, [
            0x0009,
            0x000a, 0x000d,
            0x00a0
        ]);
    }

    /** Test a whole string for validity */
    public function isStringValid(string $string): bool
    {
        $characters = str_split($string, 1);
        $skipCount = 0;
        foreach ($characters as $cindex => $character) {
            if ($skipCount > 0) {
                $skipCount--;
                continue;
            }

            $unicodePoint = EncodingConverter::utf8ToUnicode($character);
            if ($unicodePoint === false) {
                $skipCount = $this->handleMultiUnicodeCharacters($string, $cindex);
                if ($skipCount > 0) {
                    continue;
                }

            } else if ($this->isValidUnicodePoint($unicodePoint) ) {
                continue;
            }

            return false;
        }

        return true;
    }

    /** Handle unicode characters, that are not convertable as single characters
     * @param string $string String to test
     * @param int $startIndex Index of first diacritical character
     */
    protected function handleMultiUnicodeCharacters(string $string, int $startIndex): int
    {
        $diacriticalSubstring = $this->getDiacriticalSubstring($string, $startIndex);
        if (strlen($diacriticalSubstring) > 0 && $this->isDiacriticalCombinedString($diacriticalSubstring)) {
            return strlen($diacriticalSubstring)-1;
        }

        $unicodeChars = $this->getUnicodeCharacters($string, $startIndex);
        $unicodePointGroup = EncodingConverter::utf8ToUnicode($unicodeChars);
        if (strlen($unicodeChars) > 0 && $this->isValidUnicodePoint($unicodePointGroup)) {
            return strlen($unicodeChars)-1;
        }

        return 0;
    }

    /** Returns a substring of a latin character, with related diacritical combination characters
     * @param string $string String to test
     * @param int $startIndex Index of first diacritical character
     */
    protected function getDiacriticalSubstring(string $string, int $startIndex): string
    {
        $length = 0;
        foreach (str_split(substr($string, $startIndex), 1) as $character) {
            if (!$this->isDiacriticalCombinationCharacter($character)) {
                break;
            }
            $length++;
        }

        $startIndexMod = 0;
        if ($length > 0 && $this->isLatinCharacter(substr($string, $startIndex-1, 1))) {
            $startIndexMod = -1;
        }

        return substr($string, $startIndex+$startIndexMod, $length);
    }

    /** Returns a substring of characters, that should be convertable to unicode
     * @param string $string String to test
     * @param int $startIndex Index of first diacritical character
     */
    protected function getUnicodeCharacters(string $string, int $startIndex): string
    {
        $subString = '';
        foreach (str_split(substr($string, $startIndex), 1) as $character) {
            if (EncodingConverter::utf8ToUnicode($character)) {
                break;
            }
            $subString .= $character;
        }

        return $subString;
    }

    /** Test a unicode point against all validation methods */
    protected function isValidUnicodePoint(int $unicodePoint): bool
    {
        return (
            $this->isLatinUnicodePoint($unicodePoint)
            || $this->isNonLetterN1UnicodePoint($unicodePoint)
            || $this->isNonLetterN2UnicodePoint($unicodePoint)
            || $this->isNonLetterN3UnicodePoint($unicodePoint)
            || $this->isNonLetterN4UnicodePoint($unicodePoint)
        );
    }

}